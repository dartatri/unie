# -*- coding: utf-8 -*-
"""binominal_tree.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xrzWDfzEPhekKrbVBj-Y39dQ6Y-DbrBC
"""

import numpy as np
from math import log, sqrt, exp
from scipy.stats import norm

def jarrow_rudd_params(r, sigma, dt, q=0.0):
    """
    Parámetros u, d, p del esquema Jarrow–Rudd con p=0.5.
    Ecuaciones:
        e^{R dt} = (u + d)/2
        sigma*sqrt(dt) = (ln u - ln d)/2
        donde R = r - q
        => u = e^{R dt} e^{+a} * [ 2/(e^{a} + e^{-a}) ]
           d = e^{R dt} e^{-a} * [ 2/(e^{a} + e^{-a}) ]
           con a = sigma*sqrt(dt)
    """
    R = r - q
    a = sigma * np.sqrt(dt)
    C = 2.0 / (np.exp(a) + np.exp(-a))  # = 1/cosh(a)
    u = np.exp(R * dt) * np.exp(+a) * C
    d = np.exp(R * dt) * np.exp(-a) * C
    p = 0.5
    return u, d, p

def binomial_tree_prices(S0, u, d, N):
    """
    Devuelve una matriz (N+1)x(N+1) con precios del subyacente.
    Columna i = paso i; fila j = i con j bajadas (j=0..i).
    """
    S = np.zeros((N + 1, N + 1))
    S[0, 0] = S0
    for i in range(1, N + 1):
        # nivel superior (todas subidas hasta aquí)
        S[0, i] = S[0, i-1] * u
        # resto de nodos
        for j in range(1, i + 1):
            S[j, i] = S[j-1, i-1] * d
    return S

def option_payoff(S, K, option_type="call"):
    if option_type.lower() == "call":
        return np.maximum(S - K, 0.0)
    elif option_type.lower() == "put":
        return np.maximum(K - S, 0.0)
    else:
        raise ValueError("option_type debe ser 'call' o 'put'.")

def price_option_jarrow_rudd(
    S0, K, r, sigma, T, N,
    option_type="call",
    exercise="european",
    q=0.0
):
    """
    Valora una opción con árbol binomial Jarrow–Rudd (p=0.5).

    Parámetros:
        S0: precio spot
        K: strike
        r: tipo libre de riesgo (cont. compuesto)
        sigma: volatilidad anual
        T: vencimiento (en años)
        N: número de pasos del árbol
        option_type: 'call' o 'put'
        exercise: 'european' o 'american'
        q: dividend yield continuo (por defecto 0)

    Devuelve:
        precio, y un dict con (u, d, p).
    """
    dt = T / N
    u, d, p = jarrow_rudd_params(r, sigma, dt, q=q)
    disc = np.exp(-r * dt)

    # Árbol de precios del subyacente
    S = binomial_tree_prices(S0, u, d, N)

    # Payoff terminal
    V = option_payoff(S[:N+1, N], K, option_type=option_type)

    # Backward induction
    american = (exercise.lower() == "american")
    for i in range(N - 1, -1, -1):
        V = disc * (p * V[:i+1] + (1 - p) * V[1:i+2])
        if american:
            # Valor por ejercicio anticipado
            intrinsic = option_payoff(S[:i+1, i], K, option_type=option_type)
            V = np.maximum(V, intrinsic)

    price = float(V[0])
    params = {"u": u, "d": d, "p": p, "dt": dt}
    return price, params

def black_scholes_with_q(S0, K, r, q, sigma, T, option_type="call"):
    """
    Calcula el precio de una opción europea con dividend yield continuo q
    usando el modelo de Black–Scholes.

    Parámetros:
        S0: precio actual del activo
        K: precio de ejercicio
        r: tipo libre de riesgo (continuamente compuesto)
        q: tasa de dividendos continuos
        sigma: volatilidad anual
        T: tiempo hasta vencimiento (en años)
        option_type: 'call' o 'put'
    """
    # Manejo de casos límite
    if T <= 0 or sigma <= 0:
        if option_type.lower() == "call":
            return max(S0 * exp(-q*T) - K * exp(-r*T), 0.0)
        else:
            return max(K * exp(-r*T) - S0 * exp(-q*T), 0.0)

    d1 = (log(S0 / K) + (r - q + 0.5 * sigma**2) * T) / (sigma * sqrt(T))
    d2 = d1 - sigma * sqrt(T)

    if option_type.lower() == "call":
        price = S0 * exp(-q * T) * norm.cdf(d1) - K * exp(-r * T) * norm.cdf(d2)
    elif option_type.lower() == "put":
        price = K * exp(-r * T) * norm.cdf(-d2) - S0 * exp(-q * T) * norm.cdf(-d1)
    else:
        raise ValueError("option_type debe ser 'call' o 'put'.")

    return price

